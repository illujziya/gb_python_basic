# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.

# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица. 
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.

class Matrix:
    _data = []

    @staticmethod
    def check(data):
        """ Проверка корректности матрицы """
        # убеждаемся в том, что переданный параметр - не пустой список
        if type(data) != list or len(data) == 0:
            raise ValueError("Параметр должен быть не пустым списком списков с числами")
        # убеждаемся что все элементы списка тоже списки, и их элементы - числа
        for row in data:
            if type(row) != list:
                raise ValueError(f"Элементы переданного списка должны быть списками, но '{row}' имеет тип: {type(row)}")
            for value in row:
                if type(value) != int:
                    raise ValueError(f"Элементы строк матрицы должны быть числами, но '{value}' имеет тип: {type(value)}")

    @staticmethod
    def fill(data):
        """ Выравнивание матрицы: если какие-то ряды короче остальных - дополняем их нолями """
        # находим размер самого длинного ряда
        max_row_length = max(list(map(len,data)))

        # если есть ряды короче - дополняем их нолями
        for row_index in range(len(data)):
            current_length = len(data[row_index])
            if current_length < max_row_length:
                data[row_index].extend([0] * (max_row_length - current_length))
        return data

    @property
    def size(self):
        """ Возвращает размер матрицы (ряды, колонки) """        
        return (len(self._data),len(self._data[0]))

    def __init__(self, data):
        """ Создание матрицы, data = [[int]] """
        self.check(data)        
        self._data = self.fill(data)        

    def __str__(self):
        """ Преобразование в строку """
        return "\n".join(map(str,self._data))

    def __add__(self, other):
        """  Сложение матриц """
        if type(other) != Matrix:
            raise ValueError(f"Матрицы можно складывать только с другими матрицами, {type(other)} не подойдет")
        if self.size != other.size:
            raise ValueError(f"Размеры матриц должны быть одинаковыми, а тут {self.size} != {other.size}")
        
        rows, cols = self.size
        return Matrix([[ self._data[row][col] + other._data[row][col] for col in range(cols) ] for row in range(rows) ])


print("1. Матрицы без пороков")
m1 = Matrix([[1,2,3],[4,5,6],[7,8,9]])
m2 = Matrix([[9,8,7],[6,5,4],[3,2,1]])
print(m1, "+", m2, "=", m1 + m2, sep="\n")

print("2. Неровные матрицы")
m3 = Matrix([[1,2],[3],[4]])
m4 = Matrix([[4],[3,2],[1]])
print(m3, "+", m4, "=", m3 + m4, sep="\n")

# Результат запуска:
# 1. Матрицы без пороков
# [1, 2, 3]
# [4, 5, 6]
# [7, 8, 9]
# +
# [9, 8, 7]
# [6, 5, 4]
# [3, 2, 1]
# =
# [10, 10, 10]
# [10, 10, 10]
# [10, 10, 10]
# 2. Неровные матрицы
# [1, 2]
# [3, 0]
# [4, 0]
# +
# [4, 0]
# [3, 2]
# [1, 0]
# =
# [5, 2]
# [6, 2]
# [5, 0]